# -*- coding: utf-8 -*-
"""tree.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dQvrHsQvXXg0Fgh9-yv5u-ydc0orJ4N9
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline  
from sklearn.preprocessing import LabelEncoder#for train test splitting
from sklearn.model_selection import train_test_split#for decision tree object
from sklearn.tree import DecisionTreeClassifier#for checking testing results
from sklearn.metrics import classification_report, confusion_matrix#for visualizing tree 
from sklearn.tree import plot_tree
from sklearn import metrics
from sklearn.preprocessing import LabelEncoder

df = pd.read_csv('/content/drive/MyDrive/kddcup99_csv.csv')

data = df

df.shape

df.isna().sum()

# df.replace(0, np.nan, inplace=True)

#df.drop(['duration','dst_bytes','land','wrong_fragment','urgent','hot','num_failed_logins','logged_in','lnum_compromised','lroot_shell','lnum_access_files','lnum_outbound_cmds','is_host_login','is_guest_login','serror_rate','srv_serror_rate','rerror_rate','srv_rerror_rate','diff_srv_rate','srv_diff_host_rate','dst_host_diff_srv_rate','dst_host_srv_diff_host_rate','dst_host_serror_rate','lsu_attempted','lnum_file_creations','lnum_shells','lnum_root','dst_host_srv_serror_rate','dst_host_rerror_rate','dst_host_srv_rerror_rate'],inplace=True,axis=1)

# for i in df.columns[df.isnull().any(axis=0)]:     #---Applying Only on variables with NaN values
#     df[i].fillna(df[i].mean(),inplace=True)

df.protocol_type.unique()

df.service.unique()

df.flag.unique()

df.label.unique()

df['label'].value_counts()

label_encoder = LabelEncoder()
df['protocol_type'] = label_encoder.fit_transform(df['protocol_type'])

label_encoder = LabelEncoder()
df['service'] = label_encoder.fit_transform(df['service'])

label_encoder = LabelEncoder()
df['flag'] = label_encoder.fit_transform(df['flag'])

#  df.drop(['protocol_type', 'service', 'flag'],inplace=True,axis=1)

# df.drop(['lnum_outbound_cmds','is_host_login'],axis=1,inplace=True)

df.info()

sns.heatmap(df.corr())

target = df['label']
df1 = df.copy()
df1 = df1.drop('label', axis =1)

X = df1

target

#label encoding
le = LabelEncoder()
target = le.fit_transform(target)
target

y = target

# Splitting the data - 80:20 ratio
X_train, X_test, y_train, y_test = train_test_split(X , y, test_size = 0.3, random_state = 89)
print("Training split input- ", X_train.shape)
print("Testing split input- ", X_test.shape)

dtree = DecisionTreeClassifier()

# Defining the decision tree algorithmdtree=DecisionTreeClassifier()
dtree.fit(X_train,y_train)
print('Decision Tree Classifier Created')

#Predicting the values of test data
y_pred = dtree.predict(X_test)
print("Classification report - \n", classification_report(y_test,y_pred))

cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(10,10))
sns.heatmap(data=cm,linewidths=.5, annot=True,square = True,  cmap = 'Blues')
plt.ylabel('Actual label')
plt.xlabel('Predicted label')

all_sample_title = 'Accuracy Score: {0}'.format(dtree.score(X_test, y_test))
plt.title(all_sample_title, size = 15)

print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

from sklearn.metrics import classification_report, confusion_matrix
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

class_name=['normal', 'buffer_overflow', 'loadmodule', 'perl', 'neptune',
       'smurf', 'guess_passwd', 'pod', 'teardrop', 'portsweep', 'ipsweep',
       'land', 'ftp_write', 'back', 'imap', 'satan', 'phf', 'nmap',
       'multihop', 'warezmaster', 'warezclient', 'spy', 'rootkit']

# Visualising the graph without the use of graphvizplt.figure(figsize = (20,20))
dec_tree = plot_tree(decision_tree=dtree, feature_names = df1.columns, 
                     class_names =class_name , filled = True , precision = 4, rounded = True)

from sklearn.tree import export_graphviz
from six import StringIO
from IPython.display import Image  
import pydotplus

dot_data = StringIO()
export_graphviz(dtree, out_file=dot_data,  
                filled=True, rounded=True,
                special_characters=True,feature_names = df1.columns,class_names=class_name)
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
graph.write_png('dtree.png')
Image(graph.create_png())

1- 0.9895141897089187

0.9895141897089187*100

0.01048581029108131*100

98.95-100

0.98*100

fg=pd.read_csv('/content/table.csv')

fg

fg.columns



plt.figure(figsize=(7,5))
g= sns.barplot(x="Model", y="Precision ", data=fg,palette="coolwarm")
# sns.set_context('talk')
plt.xticks(rotation ='vertical')
for p in g.patches:
  g.annotate(format(p.get_height(), '.0f'),
          (p.get_x() + p.get_width() / 2., p.get_height()),
          ha = 'center', va = 'center',
          size=15,
          xytext = (0, -12),
          textcoords = 'offset points')

plt.figure(figsize=(7,5))
g= sns.barplot(x="Model", y="Recall", data=fg,palette="coolwarm")
# sns.set_context('talk')
plt.xticks(rotation ='vertical')
for p in g.patches:
  g.annotate(format(p.get_height(), '.0f'),
          (p.get_x() + p.get_width() / 2., p.get_height()),
          ha = 'center', va = 'center',
          size=15,
          xytext = (0, -12),
          textcoords = 'offset points')

plt.figure(figsize=(7,5))
g= sns.barplot(x="Model", y="Accuracy ", data=fg,palette="coolwarm")
# sns.set_context('talk')
plt.xticks(rotation ='vertical')
for p in g.patches:
  g.annotate(format(p.get_height(), '.0f'),
          (p.get_x() + p.get_width() / 2., p.get_height()),
          ha = 'center', va = 'center',
          size=15,
          xytext = (0, -12),
          textcoords = 'offset points')

plt.figure(figsize=(7,5))
g= sns.barplot(x="Model", y="Error Rate", data=fg,palette="coolwarm")
# sns.set_context('talk')
plt.xticks(rotation ='vertical')
for p in g.patches:
  g.annotate(format(p.get_height(), '.0f'),
          (p.get_x() + p.get_width() / 2., p.get_height()),
          ha = 'center', va = 'center',
          size=15,
          xytext = (0, -12),
          textcoords = 'offset points')

